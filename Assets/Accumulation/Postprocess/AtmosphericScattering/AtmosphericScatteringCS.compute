// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel TransparencyLUTPass

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> _TransparencyLUT;
float _GasDensity,_AtmosphereTop,_PlanetRadius;
int _SampleCount;
const float3 kBetaR = float3(5.802f, 13.558f, 33.100f) * 1e-3;// Rayleigh scattering coeffcient
const float3  kBetaM   = float3(0.0044f,0.0044f,0.0044f); // Mie extinction
const float3  kBetaOzone  = float3(0.000650,0.001881,0.000085);// absorption_extinction
const float kHeightR = 8.0; // scale height for rayleigh 
const float kHeightM = 1.2; // scale height for mie


//utils
float ClampDistance(float d) {
    return max(d, 0.0);
}
float ClampCosine(float mu) {
    return clamp(mu, -1.0, 1.0);
}
float ClampRadius(float r) {
    return clamp(r, _PlanetRadius, _AtmosphereTop);
}
float SafeSqrt(float a) {
    return sqrt(max(a, 0.0));
}


void GetHeightAndCosTheta(in float2 uv,out float height,out float cosT)
{
    float H = sqrt(_AtmosphereTop * _AtmosphereTop - _PlanetRadius * _PlanetRadius);
    float x_mu = uv.x;
    float x_r = uv.y;
    float rho = H * x_r;
    height = sqrt(rho * rho + _PlanetRadius * _PlanetRadius);
    float d_min = _AtmosphereTop - height;
    float d_max = rho + H;
    float d = d_min + x_mu * (d_max - d_min);
    cosT = d <= 0.0 ? float(1.0) : (H * H - rho * rho - d * d) / (2.0 * height * d);
    cosT = ClampCosine(cosT);
}

float DistanceToTopAtmosphereBoundary(float r, float mu) {
    float discriminant = r*r*(mu*mu - 1.0) + _AtmosphereTop * _AtmosphereTop;
    return ClampDistance(-r * mu + SafeSqrt(discriminant));
}

// total optical length of rayleigh and mie
float ComputeOpticalLengthToTopAtmosphereBoundary(float h_scale, float r, float mu) {
    float dx = DistanceToTopAtmosphereBoundary(r, mu) / float(_SampleCount);
    float result = 0.0;
    for (int i = 0; i <= _SampleCount; ++i) {
        float d_i = float(i) * dx;
        float r_i = sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r);
        float y_i = clamp(exp(-(r_i - _PlanetRadius) / h_scale), 0.0, 1.0);
        result += y_i * dx;
    }
    return result;
}

// total optical length of Ozone
float ComputeOpticalLengthToTopAtmosphereBoundary_O3(float r, float mu) {
    float dx = DistanceToTopAtmosphereBoundary(r, mu) / float(_SampleCount);
    float result = 0.0;
    for (int i = 0; i <= _SampleCount; ++i) {
        float d_i = float(i) * dx;
        float r_i = sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r);
        float height = r_i - _PlanetRadius;
        float linear_term = 0.0, constant_term = 0.0;
        // 2 Ozone layers
        linear_term = height < 25.0 ? 0.066667 : -0.066667;
        constant_term = height < 25.0 ? -0.66667 : 2.666667;
        float y_i = linear_term * height + constant_term;
        y_i = clamp(y_i, 0.0, 1.0);
        result += y_i * dx;
    }
    return result;
}

float3 ComputeTransmittanceToTopAtmosphereBoundary(float r, float mu) {
    float3 attenuation_rayleigh = float3(5.802f, 13.558f, 33.100f) * 1e-3 * ComputeOpticalLengthToTopAtmosphereBoundary(8.0, r, mu);
    float3 attenuation_mie = float3(0.0044f,0.0044f,0.0044f) * ComputeOpticalLengthToTopAtmosphereBoundary(1.2, r, mu);
    float3 attenuation_total = attenuation_rayleigh + attenuation_mie;
    attenuation_total += kBetaOzone * ComputeOpticalLengthToTopAtmosphereBoundary_O3(r, mu);
    return exp(-attenuation_total);
}


//通透度的lut，cosθ的一个预积分，试试看
[numthreads(8,8,1)]
void TransparencyLUTPass (uint3 id : SV_DispatchThreadID)
{
    float2 uv = id.xy / float2(256,256);
    
    float height,cosT;
    GetHeightAndCosTheta(uv,height,cosT);
    float3 col = ComputeTransmittanceToTopAtmosphereBoundary(height,cosT);
    _TransparencyLUT[id.xy] = float4(col,1);
}

